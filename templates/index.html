<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>üöÄ Ultra-Fast Stable Detection</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            min-height: 100vh; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            padding: 20px; 
        }
        h1 { 
            color: white; 
            font-size: 2.5em; 
            margin: 20px 0; 
            text-shadow: 0 2px 10px rgba(0,0,0,0.3); 
        }
        .controls { 
            display: flex; 
            gap: 15px; 
            margin-bottom: 30px; 
        }
        button { 
            padding: 15px 30px; 
            font-size: 18px; 
            font-weight: bold; 
            border: none; 
            border-radius: 50px; 
            cursor: pointer; 
            transition: all 0.3s; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.2); 
        }
        .start-btn { 
            background: linear-gradient(45deg, #00c851, #007e33); 
            color: white; 
        }
        .stop-btn { 
            background: linear-gradient(45deg, #ff4444, #cc0000); 
            color: white; 
        }
        button:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0,0,0,0.3); }
        button:active { transform: translateY(0); }
        
        .container { 
            display: flex; 
            gap: 40px; 
            margin-bottom: 30px; 
            flex-wrap: wrap; 
            justify-content: center; 
        }
        .video-box { 
            background: rgba(255,255,255,0.95); 
            padding: 25px; 
            border-radius: 20px; 
            box-shadow: 0 10px 30px rgba(0,0,0,0.2); 
            backdrop-filter: blur(10px); 
        }
        .video-box h3 { 
            color: #333; 
            margin-bottom: 15px; 
            font-size: 1.3em; 
        }
        video, canvas { 
            width: 450px; 
            height: 350px; 
            border-radius: 15px; 
            border: 4px solid #3498db; 
            box-shadow: 0 5px 20px rgba(52,152,219,0.3); 
        }
        
        .info-panel { 
            background: rgba(255,255,255,0.95); 
            padding: 30px; 
            border-radius: 20px; 
            max-width: 500px; 
            width: 100%; 
            box-shadow: 0 10px 30px rgba(0,0,0,0.2); 
            backdrop-filter: blur(10px); 
        }
        .counts { 
            background: linear-gradient(45deg, #e8f5e8, #c8e6c8); 
            padding: 25px; 
            border-radius: 15px; 
            margin: 20px 0; 
            font-size: 20px; 
            font-weight: bold; 
            color: #2e7d32; 
            min-height: 80px; 
            border: 3px solid #4caf50; 
        }
        .desc { 
            font-size: 16px; 
            color: #555; 
            margin: 15px 0; 
        }
        .stats { 
            display: flex; 
            justify-content: space-around; 
            font-size: 16px; 
            color: #666; 
        }
        .status { 
            position: fixed; 
            top: 20px; 
            right: 20px; 
            background: rgba(0,0,0,0.8); 
            color: white; 
            padding: 10px 20px; 
            border-radius: 25px; 
            font-weight: bold; 
        }
    </style>
</head>
<body>
    <div class="status" id="status">Ready</div>
    
    <h1>‚ö° ULTRA-FAST & STABLE Detection</h1>
    
    <div class="controls">
        <button class="start-btn" onclick="startDetection()">‚ñ∂Ô∏è START DETECTION</button>
        <button class="stop-btn" onclick="stopDetection()">‚èπÔ∏è STOP</button>
    </div>

    <div class="container">
        <div class="video-box">
            <h3>üì± Live Input</h3>
            <video id="video" autoplay muted playsinline></video>
        </div>
        <div class="video-box">
            <h3>üéØ Stable Output</h3>
            <canvas id="canvas"></canvas>
        </div>
    </div>

    <div class="info-panel">
        <div>üìä <strong>Live Object Counts:</strong></div>
        <div class="counts" id="counts">Click START to begin detection</div>
        <div class="desc" id="desc"></div>
        <div class="stats">
            <span id="fps">-</span>
            <span id="objects">-</span>
            <span id="tracks">-</span>
        </div>
    </div>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let isRunning = false;
        let frameCount = 0;
        let lastTime = 0;
        let fps = 0;
        let tracks = {};
        let trackId = 0;
        const SMOOTHING = 0.85;  // 85% previous + 15% new

        // Camera setup
        navigator.mediaDevices.getUserMedia({
            video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: 'user' }
        }).then(stream => {
            video.srcObject = stream;
            video.onloadedmetadata = () => {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                updateStatus('‚úÖ Camera Ready - Click START');
            };
        }).catch(err => updateStatus('‚ùå Camera Error'));

        function updateStatus(msg) {
            document.getElementById('status').textContent = msg;
        }

        function iou(box1, box2) {
            const [x1_1, y1_1, x2_1, y2_1] = box1;
            const [x1_2, y1_2, x2_2, y2_2] = box2;
            const xi1 = Math.max(x1_1, x1_2);
            const yi1 = Math.max(y1_1, y1_2);
            const xi2 = Math.min(x2_1, x2_2);
            const yi2 = Math.min(y2_1, y2_2);
            const interArea = Math.max(0, xi2 - xi1) * Math.max(0, yi2 - yi1);
            const box1Area = (x2_1 - x1_1) * (y2_1 - y1_1);
            const box2Area = (x2_2 - x1_2) * (y2_2 - y1_2);
            return interArea / (box1Area + box2Area - interArea);
        }

        function smoothTrack(prevBox, newBox) {
            return [
                SMOOTHING * prevBox[0] + (1 - SMOOTHING) * newBox[0],
                SMOOTHING * prevBox[1] + (1 - SMOOTHING) * newBox[1],
                SMOOTHING * prevBox[2] + (1 - SMOOTHING) * newBox[2],
                SMOOTHING * prevBox[3] + (1 - SMOOTHING) * newBox[3]
            ];
        }

        function processDetections(data) {
            const objects = data.objects || [];
            const matched = [];
            const used = new Set();

            // Match existing tracks
            Object.entries(tracks).forEach(([trackId, track]) => {
                let bestMatch = null;
                let bestIou = 0;
                for (let i = 0; i < objects.length; i++) {
                    if (used.has(i)) continue;
                    const iouScore = iou(track.box, objects[i].box);
                    if (iouScore > 0.5 && iouScore > bestIou) {
                        bestIou = iouScore;
                        bestMatch = i;
                    }
                }
                if (bestMatch !== null) {
                    const smoothedBox = smoothTrack(track.box, objects[bestMatch].box);
                    tracks[trackId].box = smoothedBox;
                    tracks[trackId].age = 0;
                    matched.push({ ...objects[bestMatch], box: smoothedBox, trackId, stable: true });
                    used.add(bestMatch);
                } else {
                    tracks[trackId].age++;
                    if (tracks[trackId].age < 10) {
                        matched.push({ ...objects[0] || {}, box: track.box, trackId, stable: true });
                    }
                }
            });

            // New tracks
            for (let i = 0; i < objects.length; i++) {
                if (!used.has(i)) {
                    const newId = trackId++;
                    tracks[newId] = { box: objects[i].box, age: 0 };
                    matched.push({ ...objects[i], trackId: newId, stable: false });
                }
            }

            // Cleanup old tracks
            Object.keys(tracks).forEach(id => {
                if (tracks[id].age > 15) delete tracks[id];
            });

            return matched;
        }

        async function detectFrame() {
            if (!isRunning || video.readyState !== 4) return;

            const now = performance.now();
            frameCount++;
            if (now - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = now;
            }

            // Draw background
            ctx.save();
            ctx.filter = 'blur(1px)';
            ctx.drawImage(video, 0, 0);
            ctx.restore();

            try {
                canvas.toBlob(async (blob) => {
                    const formData = new FormData();
                    formData.append('image', blob, 'frame.jpg');

                    const response = await fetch('/detect', {
                        method: 'POST',
                        body: formData
                    });
                    const data = await response.json();

                    // Update UI
                    const countsHtml = Object.entries(data.class_counts || {})
                        .map(([cls, count]) => `<div>${cls}: <strong style="color:#d32f2f">${count}</strong></div>`)
                        .join('');
                    document.getElementById('counts').innerHTML = countsHtml || 'No objects detected';
                    document.getElementById('desc').textContent = data.description?.join(', ') || '';
                    document.getElementById('fps').textContent = `FPS: ${fps}`;
                    document.getElementById('objects').textContent = `Objects: ${data.objects?.length || 0}`;
                    document.getElementById('tracks').textContent = `Tracks: ${Object.keys(tracks).length}`;

                    // Draw stable boxes
                    const stableObjects = processDetections(data);
                    stableObjects.forEach(obj => {
                        const [x1, y1, x2, y2] = obj.box;
                        const width = x2 - x1;
                        const height = y2 - y1;

                        // Stable green vs new orange
                        ctx.strokeStyle = obj.stable ? '#00ff88' : '#ffaa00';
                        ctx.lineWidth = obj.stable ? 4 : 2;
                        ctx.strokeRect(x1, y1, width, height);

                        ctx.fillStyle = obj.stable ? '#006600' : '#cc6600';
                        ctx.font = obj.stable ? 'bold 20px Arial' : '18px Arial';
                        ctx.textAlign = 'left';
                        ctx.fillText(`${obj.label} ${obj.confidence}`, x1, y1 - 10);

                        // Dimensions
                        ctx.fillStyle = 'rgba(255,255,255,0.9)';
                        ctx.font = 'bold 16px Arial';
                        ctx.fillText(`${width.toFixed(0)}√ó${height.toFixed(0)}px`, x1, y2 + 25);
                    });
                }, 'image/jpeg', 0.6);  // Fast compression
            } catch (error) {
                console.error('Detection error:', error);
            }

            if (isRunning) requestAnimationFrame(detectFrame);
        }

        function startDetection() {
            if (isRunning) return;
            isRunning = true;
            updateStatus('üî• Detecting at 60FPS...');
            detectFrame();
        }

        function stopDetection() {
            isRunning = false;
            tracks = {};
            updateStatus('‚è∏Ô∏è Stopped');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
    </script>
</body>
</html>
