<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Real-Time Object Detection</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            text-align: center; 
            color: white;
            margin: 0; padding: 20px;
        }
        h1 { 
            font-size: 2.5em; 
            margin: 20px 0; 
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        button { 
            padding: 15px 30px; 
            border: none; 
            background: linear-gradient(45deg, #4CAF50, #45a049); 
            color: white; 
            font-size: 18px; 
            border-radius: 25px; 
            cursor: pointer; 
            margin: 10px; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: all 0.3s;
        }
        button:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0,0,0,0.3); }
        .container { 
            display: flex; 
            justify-content: center; 
            gap: 50px; 
            margin-top: 30px; 
            flex-wrap: wrap;
        }
        .box { 
            background: rgba(255,255,255,0.95); 
            padding: 20px; 
            border-radius: 20px; 
            box-shadow: 0 10px 30px rgba(0,0,0,0.3); 
            backdrop-filter: blur(10px);
        }
        video, canvas { 
            width: 400px; 
            height: 300px; 
            border-radius: 15px; 
            border: 3px solid rgba(255,255,255,0.3);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        #info { 
            margin-top: 30px; 
            font-size: 20px; 
            background: rgba(76,175,80,0.9); 
            padding: 20px; 
            border-radius: 15px; 
            max-width: 500px; 
            margin: 30px auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        #counts { background: rgba(255,255,255,0.8); padding: 10px; border-radius: 8px; font-family: monospace; }
    </style>
</head>
<body>
    <h1>üñºÔ∏è REAL-TIME OBJECT DETECTION</h1>
    <button onclick="startDetection()">‚ñ∂Ô∏è Start Detection</button>
    <button onclick="stopDetection()">‚èπÔ∏è Stop Detection</button>
    
    <div class="container">
        <div class="box">
            <h3>üìπ Input (Live Camera)</h3>
            <video id="video" autoplay muted playsinline></video>
        </div>
        <div class="box">
            <h3>üéØ Output (Stable Detection)</h3>
            <canvas id="canvas"></canvas>
        </div>
    </div>
    
    <div id="info">
        <p><strong>üìä Objects by Class:</strong> <span id="counts">{}</span></p>
        <p id="desc">üîç No objects detected</p>
    </div>

    <script>
        let video = document.getElementById('video');
        let canvas = document.getElementById('canvas');
        let ctx = canvas.getContext('2d');
        let intervalId;
        
        // ANTI-FLICKER: Object tracking & smoothing
        let trackedObjects = [];
        let frameCount = 0;
        const SMOOTHING_ALPHA = 0.7;
        const MAX_FRAMES_OFF = 8;

        navigator.mediaDevices.getUserMedia({ 
            video: { width: 640, height: 480, facingMode: 'user' }
        }).then(stream => video.srcObject = stream);

        function startDetection() {
            frameCount = 0;
            trackedObjects = [];
            intervalId = setInterval(sendFrame, 120);
        }

        function stopDetection() {
            clearInterval(intervalId);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(video, 0, 0);
            trackedObjects = [];
        }

        async function sendFrame() {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            
            // Layer 1: ALWAYS fresh video
            ctx.drawImage(video, 0, 0);
            
            frameCount++;
            canvas.toBlob(async blob => {
                let formData = new FormData();
                formData.append('image', blob, 'frame.jpg');
                
                try {
                    let res = await fetch('/detect', { method: 'POST', body: formData });
                    let data = await res.json();
                    
                    // Update counts (per-class!)
                    let countsSpan = document.getElementById('counts');
                    if (Object.keys(data.count_per_class || {}).length > 0) {
                        countsSpan.innerHTML = '<pre>' + JSON.stringify(data.count_per_class, null, 2) + '</pre>';
                        document.getElementById('desc').innerText = `üéØ ${data.description.join(', ') || 'Objects'}`;
                    } else {
                        countsSpan.innerText = '{}';
                        document.getElementById('desc').innerText = 'üîç No objects detected';
                    }
                    
                    // MAGIC: Update tracking
                    updateTrackedObjects(data.objects || []);
                    drawTrackedObjects();
                    
                } catch(e) {
                    drawTrackedObjects();  // Graceful fallback
                }
            }, 'image/jpeg', 0.85);
        }

        function updateTrackedObjects(newObjects) {
            const tolerance = 60;
            newObjects.forEach(newObj => {
                let matched = false;
                for (let i = 0; i < trackedObjects.length; i++) {
                    let tracked = trackedObjects[i];
                    let newCenterX = (newObj.box[0] + newObj.box[2]) / 2;
                    let newCenterY = (newObj.box[1] + newObj.box[3]) / 2;
                    let trackedCenterX = tracked.x + tracked.w / 2;
                    let trackedCenterY = tracked.y + tracked.h / 2;
                    
                    if (Math.hypot(newCenterX - trackedCenterX, newCenterY - trackedCenterY) < tolerance) {
                        // SMOOTH UPDATE
                        tracked.x = SMOOTHING_ALPHA * newObj.box[0] + (1-SMOOTHING_ALPHA) * tracked.x;
                        tracked.y = SMOOTHING_ALPHA * newObj.box[1] + (1-SMOOTHING_ALPHA) * tracked.y;
                        tracked.w = SMOOTHING_ALPHA * (newObj.box[2]-newObj.box[0]) + (1-SMOOTHING_ALPHA) * tracked.w;
                        tracked.h = SMOOTHING_ALPHA * (newObj.box[3]-newObj.box[1]) + (1-SMOOTHING_ALPHA) * tracked.h;
                        tracked.label = newObj.label;
                        tracked.confidence = newObj.confidence;
                        tracked.width_px = newObj.width_px;
                        tracked.height_px = newObj.height_px;
                        tracked.age = 0;
                        matched = true;
                        break;
                    }
                }
                if (!matched) {
                    trackedObjects.push({
                        x: newObj.box[0], y: newObj.box[1],
                        w: newObj.box[2]-newObj.box[0], h: newObj.box[3]-newObj.box[1],
                        label: newObj.label, confidence: newObj.confidence,
                        width_px: newObj.width_px, height_px: newObj.height_px, age: 0
                    });
                }
            });
            
            // Age & prune
            trackedObjects = trackedObjects.map(o => ({...o, age: o.age+1}))
                .filter(o => o.age < MAX_FRAMES_OFF)
                .sort((a,b) => b.confidence - a.confidence);  // Best first
        }

        function drawTrackedObjects() {
            trackedObjects.forEach(obj => {
                let alpha = Math.max(0.25, 1 - obj.age * 0.1);
                
                // Background glow
                ctx.fillStyle = `rgba(50, 255, 50, ${alpha * 0.25})`;
                ctx.fillRect(obj.x-5, obj.y-5, obj.w+10, obj.h+10);
                
                // Main box
                ctx.strokeStyle = `rgba(0, 255, 0, ${alpha})`;
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.strokeRect(obj.x, obj.y, obj.w, obj.h);
                
                // Label background
                ctx.fillStyle = `rgba(0, 0, 0, ${alpha * 0.8})`;
                ctx.fillRect(obj.x, obj.y-35, 220, 30);
                
                // Label text
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                let text = `${obj.label} (${obj.confidence.toFixed(1)}) ${obj.width_px.toFixed(0)}√ó${obj.height_px.toFixed(0)}px`;
                ctx.fillText(text, obj.x + 8, obj.y - 18);
            });
        }
    </script>
</body>
</html>
